#!/bin/bash

# Load the configuration file

if [ ! -f .config ]; then
  echo "Config file not found."
  exit 1
fi

source .config

# ----------



# Help&usage

function print_help() {
  echo
}

function print_usage() {
  echo
}

# ----------

# Utils

function source_pkg_config() {
  if [[ -z "${flag_cfg_sourced}" ]]; then
    return
  fi

  local REPO="$1"; shift

  if [[ ! -d "${GLOBAL_REPO_DIR}/${REPO}" ]]; then
    echo "The repository ${REPO} has no config file."
    exit
  fi

  source "${GLOBAL_REPO_DIR}/${REPO}/.config"

  flag_cfg_sourced=1
}

# ----------



# Commands

function new_repository() {
  local NAME="$1"; shift

  cd "${GLOBAL_REPO_DIR}"

  if [[ -d "${NAME}" ]]; then
    echo "The repository already exists."
  else
    git clone --depth 1 https://github.com/cezarmathe/example_repository.git "${NAME}"

    repo-add "${NAME}.db.tar.xz"

    # TODO: change config file to match the repo name and other config variables
  fi
  
}

function initialize_build_environment() {
  local DIR="$1"; shift

  if [[ -z "${DIR}" ]]; then
    mkdir -p "${GLOBAL_BUILD_DIR}"
    mkarchroot -C /etc/pacman.conf "${GLOBAL_BUILD_DIR}/root" base-devel
  else
    if [[ "${DIR:0:1}" = "/" ]]; then
      mkdir -p "${DIR}"
      mkarchroot -C /etc/pacman.conf "${DIR}/root" base-devel
    else
      mkdir -p "${REPOTOOLS_PATH}/${DIR}"
      mkarchroot -C /etc/pacman.conf "${REPOTOOLS_PATH}/${DIR}}/root" base-devel
    fi
  fi
}

function sync_with_remote() {
  local REPO_NAME="$1"; shift

  if [[ ! -z "${REPO_NAME}" ]]; then
    # sync a single repository
    cd "${GLOBAL_REPO_DIR}"
    if [[ ! -d "${REPO_NAME}" ]]; then
      echo "Repository ${REPO_NAME} does not exist."
    else
      cd "${REPO_NAME}"

      source_pkg_config "${REPO_NAME}"

      if [[ ! -z "${LOCAL_REMOTE_GIT_ADDRESS}" ]]; then
        echo "The repository ${REPO_NAME} does not have a remote git address configured."
        return
      fi

      git remote update

      git commit -a -m "$(date)"

      local UPSTREAM=${1:-'@{u}'}
      local LOCAL=$(git rev-parse @)
      local REMOTE=$(git rev-parse "$UPSTREAM")
      local BASE=$(git merge-base @ "$UPSTREAM")

      if [ $LOCAL = $REMOTE ]; then
        echo "The repository ${REPO_NAME} is up to date."
      elif [ $LOCAL = $BASE ]; then
        echo "${REPO_NAME} is not up to date with the remote, pulling the changes.."
        git pull 

      elif [ $REMOTE = $BASE ]; then
        echo "${REPO_NAME} is ahead of the remote, pushing the changes.."            
        git push 
      else
        echo "${REPO_NAME} and the remote are diverged."
      fi
    fi
  else
    echo "Syncing all repositories."
    for reponame in "${GLOBAL_REPO_DIR}/*"; do
      bash "${REPOTOOLS_PATH}/repotools" -S "${reponame}"
    done 
  fi
}

function build_package() {
  local REPO="$1"; shift
  local PACKAGE_NAME="$1"; shift

  cd "${GLOBAL_REPO_DIR}/${REPO}"

  if [[ ! -d "src" ]]; then
    echo "The repository ${REPO} does not have packages that need to be built."
    return
  fi

  source_pkg_config "${REPO}"

  cd "src"

  if [[ ! -z "${PACKAGE_NAME}" ]]; then
    # build a single package
    if [[ ! -d "${PACKAGE_NAME}" ]]; then
      echo "The repository ${REPO} does not have a buildable package named ${PACKAGE_NAME}."
      return
    else
      cd "${PACKAGE_NAME}"
      makechrootpkg -cur "${GLOBAL_BUILD_DIR}"

      repo-add "$LOCAL_REPO_FILE" *.pkg.tar.xz
    fi
  else
    # build all packages
    echo
  fi
}

function add_package() {
  local REPO="$1"; shift
  local PACKAGE_NAME="$1"; shift

  aursync --repo "${REPO}" --root "${GLOBAL_REPO_DIR}/${REPO}" "$PACKAGE_NAME"
}

function remove_package() {
  local REPO="$1"; shift
  local PACKAGE_NAME="$1"; shift

  cd "${GLOBAL_REPO_DIR}/${PACKAGE_NAME}"

  repo-remove "${PACKAGE_NAME}.db.tar.xz" "$PACKAGE_NAME"

  rm "$PKG_NAME-*.pkg.tar.xz"
}

# ----------



# Main cli

function main() {

  while getopts 'n:a:r:sSbB:guUcm:iI:' flag; do
    case "${flag}" in
      n)
        # new repository
        flag_new_repo=1
        arg_new_repo="${OPTARG}"
        ;;
      a)
        # add a new package in the repository
        flag_add=1
        arg_add="${OPTARG}"
        ;;
      r)
        # remove the package from the repository
        flag_remove=1
        arg_remove="${OPTARG}"
        ;;
      s)
        # sync all the repositories with the remote
        flag_sync=1
        ;;
      S)
        # sync a repository with the remote
        flag_Sync=1
        ;;
      u)
        # update all packages in all repositories
        flag_update=1
        ;;
      U)
        # update all packages in a certain repository
        flag_Update=1
        ;; 
      c)
        # do a cycle
        flag_cycle=1
        ;;
      b)
        # build all packages in a repository
        flag_build=1
        ;;
      B)
        # build a package in a repository
        flag_build=1
        arg_build="${OPTARG}"
        ;;
      g)
        # build all packages in all repositories
        flag_build_all=1
      m)
        # create a new meta package in the repository
        flag_new_meta_pkg=1
        arg_new_meta_pkg="${OPTARG}"
        ;;
      i)
        # initialize the build environment
        flag_init_build_env=1
        ;;
      I)
        # initialize the build environment in a specific directory
        flag_init_build_env=1
        arg_init_build_env="${OPTARG}"
        ;;
      *)
        print_usage
        exit 1 
        ;;
    esac
  done

  # flags that are completely independent
  if [[ ! -z "${flag_new_repo}" ]]; then
    new_repository "${flag_new_repo_arg}"
  fi

  if [[ ! -z "${flag_init_build_env}" ]]; then
    initialize_build_environment "${arg_init_build_env}"
  fi

  # the cycle flag blocks other flags
  if [[ ! -z "${flag_cycle}" ]]; then
    # cycle
    exit
  fi

  # flags that do not depend on a repository name
  if [[ ! -z "${flag_sync}" ]]; then
    sync_with_remote
  fi

  if [[ ! -z "${flag_update}" ]]; then
    # update_repository
    echo
  fi

  if [[ ! -z "${flag_build_all}" ]]; then
    # build all packages
    build_all_packages
  fi

  # flags that depend on a repository name

  local REPO="$1"; shift

  if [[ -z "${REPO}" ]]; then
    echo "No repository name specified."
    exit 1
  fi

  if [[ ! -d "${REPO}" ]]; then
    echo "The repository ${REPO} does not exist."
    exit 1
  fi

  if [[ ! -z "${flag_Sync}" ]]; then
    sync_with_remote "${REPO}"
  fi

  if [[ ! -z "${flag_add}" ]]; then
    add_package "${REPO}" "${arg_add}"
    echo
  fi

  if [[ ! -z "${flag_remove}" ]]; then
    remove_package "${REPO}" "${arg_remove}"
    echo
  fi

  if [[ ! -z "${flag_Update}" ]]; then
    # update_repository "${REPO}"
    echo
  fi

  if [[ ! -z "${flag_build}" ]]; then
    # build_package "${REPO}" "${arg_build}"
    echo
  fi

  if [[ ! -z "${flag_new_meta_pkg}" ]]; then
    # create_new_meta_package "${REPO}" "${arg_new_meta_pkg}"
    echo
  fi

}

main $@