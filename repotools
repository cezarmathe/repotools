#!/bin/bash


# Load the script files

if [[ ! -d "script_files" ]]; then
  echo "The folder with the script files could not be found."
  exit 1
fi

script_files=("script_files/.config" "script_files/add_remove_packages.sh" "script_files/build_environment.sh" "script_files/build_packages.sh" "script_files/cycle.sh" "script_files/help_usage.sh" "script_files/new_meta_package.sh" "script_files/new_repository.sh" "script_files/pacman_entries.sh" "script_files/sync_repositories.sh" "script_files/update_repositories.sh" "script_files/utils.sh")

for item in ${script_files[*]}; do
  if [ ! -f "${item}" ]; then
    echo "${item} file not found."
    exit 1
  fi
  source "${item}"
done

# ----------



# Main cli

function main() {
  while getopts 'A:bB:cdgGhiI:M:nNR:sSuU' flag; do
    case "${flag}" in

      A)
        # Add a new package: -A <package_name> <repo_name> 
        flag_add=1
        arg_add="${OPTARG}"
        shift 2;;

      b)
        # Build all packages within a single repository: -b <repo_name>
        flag_build=1
        shift;;

      B)
        # Build a package: -B <package_name> <repo_name>
        flag_build=1
        arg_build="${OPTARG}"
        shift 2;;

      c)
        # Cycle: -c
        flag_cycle=1
        shift;;

      d)
        # Build all packages within all repositories: -d
        flag_build_all=1
        shift;;

      g)
        # Generate a pacman entry for all repositories: -g
        flag_generate_pacman_entry=1
        shift;;

      G)
        # Generate a pacman entry for a single repository: -G <repo_name>
        flag_Generate_pacman_entry=1
        shift;;

      h)
        # Help&usage: -h 
        print_help
        exit
        ;;
        
      i)
        # Initialize the build environment in the default directory: -i
        flag_init_build_env=1
        shift;;

      I)
        # Initialize the build environment in a specific directory: -I <directory>
        flag_init_build_env=1
        arg_init_build_env="${OPTARG}"
        shift 2;;

      M)
        # Create a new meta package: -M <package_name> <repo_name>
        flag_new_meta_pkg=1
        arg_new_meta_pkg="${OPTARG}"
        shift 2;;

      n)
        # Create a new repository for meta packages: -n <repo_name>
        flag_new_repo=1
        shift ;;
      N)
        # Create a new repository for regular packages: -N <repo_name>
        flag_new_repo=1
        arg_new_repo=1
        shift ;;
      
      R)
        # Remove a package: -R <package_name> <repo_name>
        flag_remove=1
        arg_remove="${OPTARG}"
        shift 2;;

      s)
        # Sync all repositories: -s
        flag_sync=1
        shift;;

      S)
        # Sync a single repository: -S <repo_name>
        flag_Sync=1
        shift;;

      u)
        # Update all repositories: -u
        flag_update=1
        shift;;

      U)
        # Update a single repository: -U <repo_name>
        flag_Update=1
        shift;; 
      
      *)
        print_usage
        exit 1 
        ;;

    esac
  done

  # trap remove_tmp_files EXIT

  # Flags that are completely independent
  if [[ ! -z "${flag_init_build_env}" ]]; then
    initialize_build_environment "${arg_init_build_env}"
  fi
  # ----------

  # The cycle flag blocks other flags
  if [[ ! -z "${flag_cycle}" ]]; then
    cycle
    exit
  fi
  # ----------

  # Flags that do not depend on a repository name
  if [[ ! -z "${flag_sync}" ]]; then
    # sync all repositories
    sync_with_remote
  fi

  if [[ ! -z "${flag_update}" ]]; then
    # update all repositories
    update_repository
  fi

  if [[ ! -z "${flag_build_all}" ]]; then
    # build all packages in all repositories
    build_all_packages
  fi

  if [[ ! -z "${flag_generate_pacman_entry}" ]]; then
    generate_pacman_entry
  fi
  # ----------

  # Flags that depend on a repository name
  local repository_name="$1"; shift

  # checking whether a repository name was specified
  if [[ -z "${repository_name}" ]]; then
    echo "No repository name specified."
    exit 1
  fi

  # the new repository command is executed before anything else that requires a valid repository
  if [[ ! -z "${flag_new_repo}" ]]; then
    # create a new repository
    # ${arg_new_repo} specifies whether the created repository will be a 
    # meta package repository or a regular package repository
    # new_repository "${repository_name}" "${arg_new_repo}"
    new_repository "${repository_name}"
  fi

  # checking whether the specified repository exists or not
  if [[ ! -d "${PATH_REPOSITORIES}/${repository_name}" ]]; then
    echo "The repository ${repository_name} does not exist."
    exit 1
  fi

  # source the repository config before other commands so it needs to be
  # called only once
  source_pkg_config "${repository_name}"

  # initialize git if a repository was created
  if [[ ! -z "${flag_new_repo}" ]]; then
    new_repository_init "${repository_name}"
  fi

  if [[ ! -z "${flag_Sync}" ]]; then
    # sync a single repository
    sync_with_remote "${repository_name}"
  fi

  if [[ ! -z "${flag_add}" ]]; then
    # add a package in a repository
    add_package "${repository_name}" "${arg_add}"
  fi

  if [[ ! -z "${flag_remove}" ]]; then
    # remove a package in a repository
    remove_package "${repository_name}" "${arg_remove}"
  fi

  if [[ ! -z "${flag_Update}" ]]; then
    # update packages within a repository
    update_repository "${repository_name}"
  fi

  if [[ ! -z "${flag_build}" ]]; then
    # build a package/packages within a repository
    build_package "${repository_name}" "${arg_build}"
  fi

  if [[ ! -z "${flag_new_meta_pkg}" ]]; then
    # create a new meta package in a repository
    # create_new_meta_package "${repository_name}" "${arg_new_meta_pkg}"
    echo
  fi

  if [[ ! -z "${flag_Generate_pacman_entry}" ]]; then
    generate_pacman_entry "${repository_name}"
  fi
  # ----------
}

main $@