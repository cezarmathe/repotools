#!/bin/bash


# Load the script files

if [[ ! -d "script_files" ]]; then
  echo "The folder with the script files could not be found."
  exit 1
fi

script_files=("script_files/.config" "script_files/add_remove_packages.sh" "script_files/build_environment.sh" "script_files/build_packages.sh" "script_files/help_usage.sh" "script_files/new_meta_package.sh" "script_files/new_repository.sh" "script_files/pacman_entries.sh" "script_files/sync_repositories.sh" "script_files/update_repositories.sh" "script_files/utils.sh")

for item in ${script_files[*]}; do
  if [ ! -f "${item}" ]; then
    echo "${item} file not found."
    exit 1
  fi
  source "${item}"
done

# ----------



# Main cli

function main() {

  while getopts 'N:n:a:r:sSbB:guUcm:iI:' flag; do
    case "${flag}" in

      A)
        # Add a new package: -A <package_name> <repo_name> 
        flag_add=1
        arg_add="${OPTARG}"
        shift 2;;

      d)
        # Build all packages within all repositories: -d
        flag_build_all=1
        shift;

      b)
        # Build all packages within a single repository: -b <repo_name>
        flag_build=1
        shift;;

      B)
        # Build a package: -B <package_name> <repo_name>
        flag_build=1
        arg_build="${OPTARG}"
        shift 2;;

      c)
        # Cycle: -c
        flag_cycle=1
        shift;;

      g)
        # Generate a pacman entry for all repositories: -g
        flag_generate_pacman_entry=1
        shift;

      G)
        # Generate a pacman entry for a single repository: -G <repo_name>
        flag_Generate_pacman_entry=1
        shift;

      h)
        # Help&usage: -h 
        print_help
        exit
        
      i)
        # Initialize the build environment in the default directory: -i
        flag_init_build_env=1
        shift;;

      I)
        # Initialize the build environment in a specific directory: -I <directory>
        flag_init_build_env=1
        arg_init_build_env="${OPTARG}"
        shift 2;;

      M)
        # Create a new meta package: -M <package_name> <repo_name>
        flag_new_meta_pkg=1
        arg_new_meta_pkg="${OPTARG}"
        shift 2;;

      n)
        # Create a new repository: -n <repo_name>
        flag_new_repo=1
        arg_new_repo="${OPTARG}"
        shift 2;;
      N)
        # Create a new repository and open its config in vim: -N <repo_name>
        flag_new_repo=1
        arg_new_repo="${OPTARG}"
        arg_open_config_in_editor=1
        shift 2;;
      
      R)
        # Remove a package: -R <package_name> <repo_name>
        flag_remove=1
        arg_remove="${OPTARG}"
        shift 2;;

      s)
        # Sync all repositories: -s
        flag_sync=1
        shift;;

      S)
        # Sync a single repository: -S <repo_name>
        flag_Sync=1
        shift;;

      u)
        # Update all repositories: -u
        flag_update=1
        shift;;

      U)
        # Update a single repository: -U <repo_name>
        flag_Update=1
        shift;; 
      
      *)
        print_usage
        exit 1 
        ;;

    esac
  done

  # trap remove_tmp_files EXIT

  # flags that are completely independent
  if [[ ! -z "${flag_new_repo}" ]]; then
    new_repository "${arg_new_repo}"
  fi

  if [[ ! -z "${flag_init_build_env}" ]]; then
    initialize_build_environment "${arg_init_build_env}"
  fi

  # the cycle flag blocks other flags
  if [[ ! -z "${flag_cycle}" ]]; then
    # cycle
    exit
  fi

  # flags that do not depend on a repository name
  if [[ ! -z "${flag_sync}" ]]; then
    sync_with_remote
  fi

  if [[ ! -z "${flag_update}" ]]; then
    update_repository
    echo
  fi

  if [[ ! -z "${flag_build_all}" ]]; then
    build_all_packages
  fi

  # flags that depend on a repository name

  local REPO="$1"; shift

  if [[ -z "${REPO}" ]]; then
    echo "No repository name specified."
    exit 1
  fi

  if [[ ! -d "${GLOBAL_REPO_DIR}/${REPO}" ]]; then
    echo "The repository ${REPO} does not exist."
    exit 1
  fi

  if [[ ! -z "${flag_Sync}" ]]; then
    sync_with_remote "${REPO}"
  fi

  if [[ ! -z "${flag_add}" ]]; then
    add_package "${REPO}" "${arg_add}"
  fi

  if [[ ! -z "${flag_remove}" ]]; then
    remove_package "${REPO}" "${arg_remove}"
  fi

  if [[ ! -z "${flag_Update}" ]]; then
    update_repository "${REPO}"
  fi

  if [[ ! -z "${flag_build}" ]]; then
    build_package "${REPO}" "${arg_build}"
  fi

  if [[ ! -z "${flag_new_meta_pkg}" ]]; then
    # create_new_meta_package "${REPO}" "${arg_new_meta_pkg}"
    echo
  fi

}

main $@