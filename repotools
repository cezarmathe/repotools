#!/bin/bash

# Load the configuration file

if [ ! -f .config ]; then
  echo "Config file not found."
  exit 1
fi

source .config

# ----------



# Help&usage

function print_help() {
  echo
}

function print_usage() {
  echo
}

# ----------

# Utils

function source_pkg_config() {

  local REPO="$1"; shift

  if [[ ! -f "${GLOBAL_REPO_DIR}/${REPO}/.config" ]]; then
    echo "The repository ${REPO} has no config file."
    exit
  fi

  source "${GLOBAL_REPO_DIR}/${REPO}/.config"

  echo "${LOCAL_DB_FILE}"
}

function remove_tmp_files() {
  rm "${REPOTOOLS_PATH}"/*.tmp
}

# ----------



# Commands

function new_repository() {
  local NAME="$1"; shift

  if [[ -d "${GLOBAL_REPO_DIR}/${NAME}" ]]; then
    echo "The repository already exists."
  else
    git clone --depth 1 https://github.com/cezarmathe/example_repository.git "${GLOBAL_REPO_DIR}/${NAME}"

    repo-add "${GLOBAL_REPO_DIR}/${NAME}/pkg/${NAME}.db.tar.xz"

    if [[ ! -z "${arg_open_config_in_editor}" ]]; then
      vim "${GLOBAL_REPO_DIR}/${NAME}/.config"
    fi

    # TODO: change config file to match the repo name and other config variables
  fi
  
}

function initialize_build_environment() {
  local DIR="$1"; shift

  if [[ -z "${DIR}" ]]; then
    mkdir -p "${GLOBAL_BUILD_DIR}"
    mkarchroot -C /etc/pacman.conf "${GLOBAL_BUILD_DIR}/root" base-devel
  else
    if [[ "${DIR:0:1}" = "/" ]]; then
      mkdir -p "${DIR}"
      mkarchroot -C /etc/pacman.conf "${DIR}/root" base-devel
    else
      mkdir -p "${REPOTOOLS_PATH}/${DIR}"
      mkarchroot -C /etc/pacman.conf "${REPOTOOLS_PATH}/${DIR}}/root" base-devel
    fi
  fi
}

function sync_with_remote() {
  local REPO_NAME="$1"; shift

  if [[ ! -z "${REPO_NAME}" ]]; then
    # sync a single repository
    if [[ ! -d "${GLOBAL_REPO_DIR}/${REPO_NAME}" ]]; then
      echo "Repository ${REPO_NAME} does not exist."
    else

      source_pkg_config "${REPO_NAME}"

      if [[ ! -z "${LOCAL_REMOTE_GIT_ADDRESS}" ]]; then
        echo "The repository ${REPO_NAME} does not have a remote git address configured."
        return
      fi

      git --work-tree="${GLOBAL_REPO_DIR}/${REPO_NAME}/" --git-dir="${GLOBAL_REPO_DIR}/${REPO_NAME}/.git"  remote update

      git --work-tree="${GLOBAL_REPO_DIR}/${REPO_NAME}/" --git-dir="${GLOBAL_REPO_DIR}/${REPO_NAME}/.git" commit -a -m "$(date)"

      local UPSTREAM=${1:-'@{u}'}
      local LOCAL=$(git --work-tree=${GLOBAL_REPO_DIR}/${REPO_NAME}/ --git-dir=${GLOBAL_REPO_DIR}/${REPO_NAME}/.git rev-parse @)
      local REMOTE=$(git --work-tree=${GLOBAL_REPO_DIR}/${REPO_NAME}/ --git-dir=${GLOBAL_REPO_DIR}/${REPO_NAME}/.git rev-parse "$UPSTREAM")
      local BASE=$(git --work-tree=${GLOBAL_REPO_DIR}/${REPO_NAME}/ --git-dir=${GLOBAL_REPO_DIR}/${REPO_NAME}/.git merge-base @ "$UPSTREAM")

      if [ $LOCAL = $REMOTE ]; then
        echo "The repository ${REPO_NAME} is up to date."
      elif [ $LOCAL = $BASE ]; then
        echo "${REPO_NAME} is not up to date with the remote, pulling the changes.."
        git --work-tree="${GLOBAL_REPO_DIR}/${REPO_NAME}/" --git-dir="${GLOBAL_REPO_DIR}/${REPO_NAME}/.git" pull 

      elif [ $REMOTE = $BASE ]; then
        echo "${REPO_NAME} is ahead of the remote, pushing the changes.."            
        git --work-tree="${GLOBAL_REPO_DIR}/${REPO_NAME}/" --git-dir="${GLOBAL_REPO_DIR}/${REPO_NAME}/.git" push 
      else
        echo "${REPO_NAME} and the remote are diverged."
      fi
    fi
  else
    echo "Syncing all repositories."
    for reponame in "${GLOBAL_REPO_DIR}/*"; do
      bash "${REPOTOOLS_PATH}/repotools" -S "${reponame}"
    done 
  fi
}

function build_package() {
  local REPO="$1"; shift
  local PACKAGE_NAME="$1"; shift

  if [[ ! -d "${GLOBAL_REPO_DIR}/${REPO}/src" ]]; then
    echo "The repository ${REPO} does not have packages that need to be built."
    return
  fi

  source_pkg_config "${REPO}"

  if [[ ! -z "${PACKAGE_NAME}" ]]; then
    # build a single package
    if [[ ! -d "${GLOBAL_REPO_DIR}/${REPO}/src/${PACKAGE_NAME}" ]]; then
      echo "The repository ${REPO} does not have a buildable package named ${PACKAGE_NAME}."
      return
    else
      local previous_wd="$(pwd)"

      cd "${GLOBAL_REPO_DIR}/${REPO}/src/${PACKAGE_NAME}"
      makechrootpkg -cur "${GLOBAL_BUILD_DIR}"

      repo-add "${GLOBAL_REPO_DIR}/${REPO}/${LOCAL_DB_FILE}" *.pkg.tar.xz

      cd "${previous_wd}"
    fi
  else

    echo "$(ls ${GLOBAL_REPO_DIR}/${REPO}/src)" > "packages.tmp"

    trap remove_tmp_files EXIT

    while read -r line; do
      bash "${REPOTOOLS_PATH}/repotools" -B "${line}" "${REPO}"
    done < "packages.tmp"
  fi
}

function add_package() {
  local REPO="$1"; shift
  local PACKAGE_NAME="$1"; shift

  aursync --repo "${REPO}" --root "${GLOBAL_REPO_DIR}/${REPO}" "$PACKAGE_NAME"
}

function remove_package() {
  local REPO="$1"; shift
  local PACKAGE_NAME="$1"; shift

  source_pkg_config "${REPO}"

  cd "${GLOBAL_REPO_DIR}/${REPO}"

  repo-remove "${GLOBAL_REPO_DIR}/${REPO}/${LOCAL_DB_FILE}" "$PACKAGE_NAME"

  rm "${GLOBAL_REPO_DIR}/${REPO}/pkg/$PKG_NAME-*.pkg.tar.xz"
}

function build_all_packages() {
  echo "$(ls ${GLOBAL_REPO_DIR})" > "repositories.tmp"

  # trap remove_tmp_files EXIT

  while read -r line; do
    bash "${REPOTOOLS_PATH}/repotools" -b "${line}"
  done < "repositories.tmp"
}

# ----------



# Main cli

function main() {

  while getopts 'N:n:a:r:sSbB:guUcm:iI:' flag; do
    case "${flag}" in
      n)
        # new repository
        flag_new_repo=1
        arg_new_repo="${OPTARG}"
        shift 2;;
      N)
        # new repository which opens the config file in the editor
        flag_new_repo=1
        arg_new_repo="${OPTARG}"
        arg_open_config_in_editor=1
        shift 2;;
      a)
        # add a new package in the repository
        flag_add=1
        arg_add="${OPTARG}"
        shift 2;;
      r)
        # remove the package from the repository
        flag_remove=1
        arg_remove="${OPTARG}"
        shift 2;;
      s)
        # sync all the repositories with the remote
        flag_sync=1
        shift;;
      S)
        # sync a repository with the remote
        flag_Sync=1
        shift;;
      u)
        # update all packages in all repositories
        flag_update=1
        shift;;
      U)
        # update all packages in a certain repository
        flag_Update=1
        shift;; 
      c)
        # do a cycle
        flag_cycle=1
        shift;;
      b)
        # build all packages in a repository
        flag_build=1
        shift;;
      B)
        # build a package in a repository
        flag_build=1
        arg_build="${OPTARG}"
        shift 2;;
      g)
        # build all packages in all repositories
        flag_build_all=1
        shift;;
      m)
        # create a new meta package in the repository
        flag_new_meta_pkg=1
        arg_new_meta_pkg="${OPTARG}"
        shift 2;;
      i)
        # initialize the build environment
        flag_init_build_env=1
        shift;;
      I)
        # initialize the build environment in a specific directory
        flag_init_build_env=1
        arg_init_build_env="${OPTARG}"
        shift 2;;
      *)
        print_usage
        exit 1 
        ;;
    esac
  done

  # flags that are completely independent
  if [[ ! -z "${flag_new_repo}" ]]; then
    new_repository "${arg_new_repo}"
  fi

  if [[ ! -z "${flag_init_build_env}" ]]; then
    initialize_build_environment "${arg_init_build_env}"
  fi

  # the cycle flag blocks other flags
  if [[ ! -z "${flag_cycle}" ]]; then
    # cycle
    exit
  fi

  # flags that do not depend on a repository name
  if [[ ! -z "${flag_sync}" ]]; then
    sync_with_remote
  fi

  if [[ ! -z "${flag_update}" ]]; then
    # update_repository
    echo
  fi

  if [[ ! -z "${flag_build_all}" ]]; then
    build_all_packages
  fi

  # flags that depend on a repository name

  local REPO="$1"; shift

  if [[ -z "${REPO}" ]]; then
    echo "No repository name specified."
    exit 1
  fi

  if [[ ! -d "${GLOBAL_REPO_DIR}/${REPO}" ]]; then
    echo "The repository ${REPO} does not exist."
    exit 1
  fi

  if [[ ! -z "${flag_Sync}" ]]; then
    sync_with_remote "${REPO}"
  fi

  if [[ ! -z "${flag_add}" ]]; then
    add_package "${REPO}" "${arg_add}"
  fi

  if [[ ! -z "${flag_remove}" ]]; then
    remove_package "${REPO}" "${arg_remove}"
  fi

  if [[ ! -z "${flag_Update}" ]]; then
    # update_repository "${REPO}"
    echo
  fi

  if [[ ! -z "${flag_build}" ]]; then
    build_package "${REPO}" "${arg_build}"
  fi

  if [[ ! -z "${flag_new_meta_pkg}" ]]; then
    # create_new_meta_package "${REPO}" "${arg_new_meta_pkg}"
    echo
  fi

}

main $@