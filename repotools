#!/bin/bash

# Load the configuration file

if [ ! -f .config ]; then
  echo "Config file not found."
  exit 1
fi

source .config

# ----------



# Help&usage

function print_help() {
  echo
}

function print_usage() {
  echo
}

# ----------



# Commands

function new_repository() {
  local NAME="$1"; shift

  cd "${GLOBAL_REPO_DIR}"

  if [[ -d "${NAME}" ]]; then
    echo "The repository already exists."
  else
    git clone https://github.com/cezarmathe/example_repository.git "${NAME}"

    # TODO: change config file to match the repo name and other config variables
  fi
  
}

function initialize_build_environment() {
  local DIR="$1"; shift

  if [[ -z "${DIR}" ]]; then
    mkdir -p "${GLOBAL_BUILD_DIR}"
    mkarchroot -C /etc/pacman.conf "${GLOBAL_BUILD_DIR}/root" base-devel
  else
    if [[ "${DIR:0:1}" = "/" ]]; then
      mkdir -p "${DIR}"
      mkarchroot -C /etc/pacman.conf "${DIR}/root" base-devel
    else
      mkdir -p "${REPOTOOLS_PATH}/${DIR}"
      mkarchroot -C /etc/pacman.conf "${REPOTOOLS_PATH}/${DIR}}/root" base-devel
    fi
  fi
}

function sync_with_remote() {
  local REPO_NAME="$1"; shift

  if [[ ! -z "${REPO_NAME}" ]]; then
    # sync a single repository
    cd "${GLOBAL_REPO_DIR}"
    if [[ ! -d "${REPO_NAME}" ]]; then
      echo "Repository ${REPO_NAME} does not exist."
    else
      cd "${REPO_NAME}"

      if [[ ! -f ".config" ]]; then
        echo "The repository ${REPO_NAME} has no config file."
      else
        source ./.config

        # Check local configuration to create a final address for pulling and pushing to this repository
        local ADDRESS=""
        if [[ ! -z "${LOCAL_REMOTE_USER}" ]]; then
          ADDRESS="${LOCAL_REMOTE_USER}@"
        else
          ADDRESS="${GLOBAL_REMOTE_USER}@"
        fi

        if [[ ! -z "${LOCAL_REMOTE_ADDRESS}" ]]; then
          ADDRESS+="${LOCAL_REMOTE_ADDRESS}"
        else
          ADDRESS+="${GLOBAL_REMOTE_ADDRESS}"
        fi

        if [[ ! -z "${LOCAL_REMOTE_PORT}" ]]; then
          ADDRESS+=":${LOCAL_REMOTE_PORT}"
        fi

        if [[ -z "${LOCAL_REMOTE_ENDPOINT}" ]]; then
          echo "The repository ${REPO_NAME} does not have a remote endpoint specified in its configuration file."
          return
        fi

        ADDRESS+="/${LOCAL_REMOTE_ENDPOINT}"

        git fetch "${ADDRESS}"

        local UPSTREAM=${1:-'@{u}'}
        local LOCAL=$(git rev-parse @)
        local REMOTE=$(git rev-parse "$UPSTREAM")
        local BASE=$(git merge-base @ "$UPSTREAM")

        if [ $LOCAL = $REMOTE ]; then
            echo "The repository ${REPO_NAME} is up to date."
        elif [ $LOCAL = $BASE ]; then
            echo "${REPO_NAME} is not up to date with the remote, pulling the changes.."

            git pull "${ADDRESS}" master

        elif [ $REMOTE = $BASE ]; then
            echo "${REPO_NAME} is ahead of the remote, pushing the changes.."

            git add *
            git commit -m "$(date)"
            git push "${ADDRESS}" master
        else
            echo "${REPO_NAME} and the remote are diverged."
        fi
      fi
    fi
  else
    echo "wip"
    # sync all repositories

  fi
}

# ----------



# Main cli

function main() {
  # local REPOSITORY="$1"; shift

  # if [[ -z "$SUBCOMMAND" ]]; then
  #   echo "No subcommand specified. Run \"./repotools help\" if you need help."
  #   exit 1
  # fi

  while getopts 'n:a:r:sS:bB:ucm:iI:' flag; do
    case "${flag}" in
      n)
        # new repository
        new_repository "${OPTARG}"
        ;;
      a)
        # add a new package in the repository
        ;;
      r)
        # remove the package from the repository
        ;;
      s)
        # sync all the repositories with the remote
        sync_with_remote
        ;;
      S)
        # sync a repository with the remote
        sync_with_remote "${OPTARG}"
        ;;
      u)
        # update the packages in the repository
        ;;
      c)
        # do a cycle
        ;;
      b)
        # build all packages in a repository
        ;;
      B)
        # build a package in a repository
        ;;
      m)
        # create a new meta package in the repository
        ;;
      i)
        # initialize the build environment
        initialize_build_environment 
        ;;
      I)
        # initialize the build environment in a specific directory
        initialize_build_environment "${OPTARG}"
        ;;
      *)
        print_usage
        exit 1 ;;
    esac
  done

  # case "$SUBCOMMAND" in

  #   "help")
  #     print_help $@
  #     exit
  #     ;;

  #   "clone-repo"

  # esac
}

main $@